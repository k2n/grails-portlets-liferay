import grails.util.GrailsUtil
import groovy.xml.StreamingMarkupBuilder
import org.codehaus.groovy.grails.commons.ConfigurationHolder as CH
import org.springframework.core.io.support.PathMatchingResourcePatternResolver

eventPackagingEnd = {
  def searchPath = "file:${basedir}/grails-app/portlets/**/*Portlet.groovy"
  def portletFiles = resolveResources(searchPath).toList()
  generateLiferayDisplayXml(portletFiles)
  generateLiferayPortletXml(portletFiles)
  generateLiferayPluginPackageProperties()
}

// Those jars are loaded at parents classloaders, 
// and causes silent portlet deployment failure if included.
eventCreateWarStart = { warName, stagingDir ->
    ant.delete {
      fileset(dir:"${stagingDir}/WEB-INF/lib") {
       include(name: "servlet-api*.jar")
       include(name: "portal-kernel*.jar")
       include(name: "portal-service*.jar")
       include(name: "portlet-api*.jar")
       include(name: "jcl-over-slf4j*.jar")
      }
   }
}

def resolveResources(String pattern) {
    def resolver = new PathMatchingResourcePatternResolver()
    return resolver.getResources(pattern)
}

def generateLiferayDisplayXml(portletFiles) {
    def liferayDisplayXml = new File("${basedir}/web-app/WEB-INF/liferay-display.xml")
    if(liferayDisplayXml.exists()) liferayDisplayXml.delete()
    def xmlWriter = new StreamingMarkupBuilder()
    def xml = xmlWriter.bind {
        mkp.yieldUnescaped '<?xml version="1.0" encoding="UTF-8"?>' 
        mkp.yieldUnescaped '<!DOCTYPE display PUBLIC "-//Liferay//DTD Display 5.1.0//EN" "http://www.liferay.com/dtd/liferay-display_5_1_0.dtd">'
        mkp.comment 'GENERATED BY GRAILS PORTLETS PLUGIN - DO NOT EDIT AND CONFIGURE IN PORTLET groovy' 
        'display'
        {
            portletFiles.each {portletClassFile ->
                def className = portletClassFile.filename - '.groovy'
                Class portletClass = classLoader.loadClass(className)
                def portletName = className - 'Portlet'
                def instance = portletClass.newInstance()
                if(hasProperty('liferay_display_category', instance)) {
                    'category'(name: "${instance.liferay_display_category}") {
                        'portlet'(id: portletName)
                    }
                }
            }
        }
    }
    liferayDisplayXml.write(xml.toString())
}

def generateLiferayPortletXml(portletFiles) {

    def mappers = [:] 
    if(CH.config.liferay.portlet_role_mappers != null) {
        mappers = CH.config.liferay.portlet_role_mappers
        assert (mappers instanceof Map) 
    } else {
        mappers = ['administrator':'Administrator', 'guest':'Guest', 'power-user':'Power User', 'user':'User']
    }

    def attribs = [:]
    if(CH.config.liferay.portlet_custom_user_attributes != null) {
        attribs = CH.config.liferay.portlet_custom_user_attributes
        assert (attribs instanceof Map)
    }

    def liferayPortletXml = new File("${basedir}/web-app/WEB-INF/liferay-portlet.xml")
    if(liferayPortletXml.exists()) liferayPortletXml.delete()
    def xmlWriter = new StreamingMarkupBuilder()
    def xml = xmlWriter.bind {
        mkp.yieldUnescaped '<?xml version="1.0" encoding="UTF-8"?>' 
        mkp.yieldUnescaped '<!DOCTYPE liferay-portlet-app PUBLIC "-//Liferay//DTD Portlet Application 5.1.0//EN" "http://www.liferay.com/dtd/liferay-portlet-app_5_1_0.dtd">'
        mkp.comment 'GENERATED BY GRAILS PORTLETS LIFERAY PLUGIN - DO NOT EDIT THIS FILE.' 
        'liferay-portlet-app' {
            portletFiles.each {portletClassFile ->
               def className = portletClassFile.filename - '.groovy'
               Class portletClass = classLoader.loadClass(className)
               def portletName = className - 'Portlet'
               def instance = portletClass.newInstance()
               'portlet' {
                   'portlet-name'(portletName)
                   def fields = portletClass.declaredFields
                   def dtd_portlet = [
                    'icon', 'virtual_path', 'struts_path',
                    'configuration_path', 'configuration_action_class', 'indexer_class',
                    'open_search_class', 'scheduler_class', 'portlet_url_class',
                    'friendly_url_mapper_class', 'url_encoder_class', 'portlet_data_handler_class',
                    'portlet_layout_listener_class', 'pop_message_listener_class',
                    'social_activity_interpreter_class', 'social_request_interpreter_class',
                    'preferences_company_wide', 'preferences_unique_per_layout',
                    'preferences_owned_by_group', 'use_default_template', 'show_portlet_access_denied',
                    'show_portlet_inactive', 'action_url_redirect', 'restore_current_view',
                    'maximize_edit', 'maximize_help', 'pop_up_print', 'layout_cacheable', 'instanceable',
                    'user_principal_strategy', 'private_request_attributes',
                    'private_session_attributes', 'render_weight', 'ajaxable', 'header_portal_css',
                    'header_portlet_css', 'header_portal_javascript', 'header_portlet_javascript',
                    'footer_portal_css', 'footer_portlet_css', 'footer_portal_javascript',
                    'footer_portlet_javascript', 'css_class_wrapper', 'facebook_integration',
                    'add_default_resource', 'system', 'active', 'include' ]

                   dtd_portlet.each { elementName ->
                       def field = fields.find { 
                           it.name == 'liferay_portlet_' + elementName
                       }
                       if(field) {
                           field.setAccessible(true)
                           def element = (field.name - 'liferay_portlet_').replace('_','-')
                           if(field.get(instance) instanceof List) {
                               field.get(instance).each {
                                   invokeMethod(element, it.toString())
                               }
                           } else {
                               invokeMethod(element, field.get(instance).toString())
                           }
                       }
                   }
               }
            }
           mappers.each { role ->
               'role-mapper' {
                   'role-name'(role.key)
                   'role-link'(role.value)
               }
           }
           attribs.each { attrib ->
               'custom-user-attribute' {
                   'name'(attrib.key)
                   'custom-class'(attrib.value)
               }
           }
       }
    }
    liferayPortletXml.write(xml.toString())
}

def generateLiferayPluginPackageProperties() {
    def liferayPluginPackageProperties = new
    File("${basedir}/web-app/WEB-INF/liferay-plugin-package.properties")
    if(liferayPluginPackageProperties.exists()) {
        liferayPluginPackageProperties.delete() 
    }
    if(CH.config.liferay.get('plugin_package') != null) {
        def conf =
        CH.config.liferay.get('plugin_package')
        def rconf = new ConfigObject()
        conf.each {key, value ->
            rconf += [(key.replace('_','-')):(value)]
        }
        rconf.toProperties().store(liferayPluginPackageProperties.newOutputStream(), 
        "This is generated by Grails. The changes will be overwritten. Edit 'liferay.grails-app/conf/Config.groovy.")
    }
}

def hasProperty(propertyName, instance) {
    try {
        def value = instance."${propertyName}"
        return true;
    } catch (MissingPropertyException mpe) {
        return false;
    }
}

